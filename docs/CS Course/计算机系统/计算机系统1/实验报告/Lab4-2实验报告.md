# **Lab4-2实验报告**

## 破译密码

1.  **实验结果图：**

    ![image-20240210195358564](./4-2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8Aimg/image-20240210195358564.png)

2.  **实验步骤阐述：**

    1.  **随便尝试一组学号的密码**

        ![image-20240210195404049](./4-2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8Aimg/image-20240210195404049.png)

    2.  **在check处设置断点，并运行程序至check，从check开始逐步观察**

        ![image-20240210195411840](./4-2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8Aimg/image-20240210195411840.png)

    3.  **发现一处类似循环的代码**

        ![image-20240210195417802](./4-2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8Aimg/image-20240210195417802.png)

    4.  **在该代码后的位置设置断点，并运行程序跳过循环**

        ![image-20240210195424719](./4-2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8Aimg/image-20240210195424719.png)

    5.  **继续执行发现一处比较代码，比较后跳转至a0 = -1，并且程序结束**

        ![image-20240210195430178](./4-2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8Aimg/image-20240210195430178.png)

    6.  **观察在比较时，两个被比较寄存器的值**

        ![image-20240210195435420](./4-2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8Aimg/image-20240210195435420.png)

    7.  **猜测一个是我输入的密码，一个是由我的学号生成的实际的密码**

    8.  **再运行程序，输入实际密码，结束**

## 拆炸弹

### 第一颗

![image-20240210195445641](./4-2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8Aimg/image-20240210195445641.png)

1.  **调试方法：**

    进入phase_1观察后续调用函数read_four_integer猜测后续读入四个整数，a0返回判断是否是4猜测是输入整数的个数。后根据汇编代码发现栈内元素依次和3，7，11比较，且最后一个数字赋值给a0后经过一系列计算实现与15比较，因此推出答案是3 7 11 15

### 第二颗

![image-20240210195534191](./4-2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8Aimg/image-20240210195534191.png)

1.  **调试方法：**

    进入phase_2观察，得知函数将0x5e758开始的16字节内容搬运到phase_2的栈内，再发现后续跳转到memcmp函数中时特地在a1处存放了sp，猜测该函数用于比较。后续调试过程中又发现a0存放了输入的值，最后也是a0和sp在比较，因此只需要将sp内容换成ascii码即可

### 第三颗

![image-20240210195542350](./4-2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8Aimg/image-20240210195542350.png)

1.  **调试方法：**

    进入phase_3观察，得知函数在读数后有一系列对于8(sp)的计算。第一个条件要8(sp)∈\[100,106\]之间。此时可以开始枚举第三个炸弹的答案，但是为了人生安全起见，我们继续看后面的代码。

    代码将a5\*4，然后对应到后面的一张表上，表中只有当a5取4时能够让a0=0，拆弹成功。因此第三个炸弹的密码为104。

### 第四颗

![](./4-2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8Aimg/image-20240210195550034.png)

1.  **调试方法：**

    进入phase_4观察，检查栈的元素得知我输入的两个数被存在栈内，而后在secret_func处设置断点，得知函数通过secret_func计算两个数的最大公约数，返回在a0。而后又计算了一堆num1和num2应该满足的条件，即num1,num2 \>= a0\*10,num2 \>= num1即可，随便假设a0 == 4，num1 == 44，num2 == 52成立。&nbsp;

2.  **调试方法：**

    进入phase_1观察后续调用函数read_four_integer猜测后续读入四个整数，a0返回判断是否是4猜测是输入整数的个数。后根据汇编代码发现栈内元素依次和3，7，11比较，且最后一个数字赋值给a0后经过一系列计算实现与15比较，因此推出答案是3 7 11 15
